/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi


 **/


options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
 
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.*;

@SuppressWarnings("serial")
public class Robot 
{

	ArrayList<String> listaVariables = new ArrayList<String>();
	Map<String, Integer> mapaVariables = new HashMap<String, Integer >();

	boolean ejecutar = false;

	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
	" "
	|	"\r"
	|	"\t"
	| "\n"
}



// ------------------------------TOKENS----------------------------------

TOKEN: /* Nombres de Comandos */
{

	<MOVE:  "MOVE">|	//(NUM) -> move forward num steps
	<RIGHT: "right">|
	<PUT: "PUT">|		// (chips|balloons, num) -> drop num chips|balloons
	<PICK: "PICK">|		// (chips|balloons, num) -> pickup num chips|baloons
	< POP: "POP" >|		// (num) -> pop num balloons
    < HOP:  "HOP" >|	// (num) -> hop num positions forward
   	<GO: "GO" >|	    // (num, num) -> go to the position num,num. [x,y] en el enunciado
   	< ROBOT_R: "ROBOT_R" >| // X
  	< VARS: "VARS" >| // X
  	< PROCS: "PROCS" > // X

}

TOKEN: // Comandos pt2
{
  < ASSIGNTO: "assignTo" >|
  < GOTO: "goto" >|
  < TURN: "turn" >|
  < FACE: "face" >|
  < MOVETOTHE: "moveToThe" >|
  < MOVEINDIR: "moveInDir" >|
  < JUMPTOTHE: "jumpToThe" >|
  < JUMPINDIR: "jumpInDir" >|
  < NOP: "nop" >
}

TOKEN: // Estructuras de control
{
  < IF: "if" >|
  < THEN: "then" >|
  < ELSE: "else" >|

  < WHILE: "while" >|
  < DO: "do" >|

  < REPEAT: "repeat" >
}

TOKEN: // Condiciones
{
  < FACING: "facing" >|
  < CANPUT: "canPut" >|
  < CANPICK: "canPick" >|
  < CANMOVEINDIR: "canMoveInDir" >|
  < CANJUMPINDIR: "canJumpInDir" >|
  < CANMOVETOTHE: "canMoveToThe" >|
  < CANJUMPTOTHE: "canJumpToThe" >|
  < NOT: "not" >
}

TOKEN: //Tipos de datos
{
  
// D: (EN ALGUNAS PARTES DE EL ENUNCIADO ES O)
  
  < FRONT: "FRONT" >|
  < LEFT: "LEFT" >|
  < BACK: "BACK" >|

  < AROUND: "AROUND" >|
  
  // O: (EN ALGUNAS PARTES DEL ENUNCIADO ES D)
  < NORTH: "NORTH" >|
  < SOUTH: "SOUTH" >|
  < EAST: "EAST" >|
  < WEST: "WEST" >|
  < NUM : (["0"-"9"])+>| /* n, x, y entran en la categoria de numero*/
  < CHIPS : "CHIPS">| // X
  < BALLOONS: "BALLOONS" >| // X
  < NAME: (< STR >)+ >| // cualquier string (variables nombres de procedimientos etc)
  < #STR: ["a"-"z"]|["A"-"Z"]>
  
}

// ----------------------------------PRODUCCIONES----------------------------------



	//boolean command(uniandes.lym.robot.view.Console sistema) :
	boolean command(Console sistema): // Comandos1
	{	
		int x,y;
		salida=new String();	
	}

	{
		(
		  (
		   <RIGHT> "(" ");" {world.turnRight();salida = "Command: Turnright";}
		| 	<MOVE>  "(" x=num() ");" {world.moveForward(x,false);salida = "Command: Moveforward ";}  
		| 	<HOP>  "(" x=num() ");" {world.moveForward(x,true);salida = "Command:Jumpforward ";}
		| 	<GO>  "(" x=num() "," y=num()");" {world.setPostion(x,y);salida = "Command:GO ";}  
		|  <PUT> "("  put() ");"					  			
		|  <PICK> "(" get()  ");"	
	    |  < POP > "(" x=num() ");" {world.popBalloons(x); salida = "Comando:  Pop";}
	    |  robot()
		) 

		{
		    try {
	    			 Thread.sleep(900);
	    	    } catch (InterruptedException e) {
	    			        System.err.format("IOException: %s%n", e);
	    		    }
	    			 
			sistema.printOutput(salida);
			return true;
		})

    	| <EOF> {return false;} 
	}

	

	void command2():
	{
		Token name = new Token();
		int num = 0;
		
		int xInt = -1;
		int yInt = -1;
		Token xVar = new Token();
		Token yVar = new Token();
	  }
	
	{
	  //-------------------assignTo-----------------------
	  < ASSIGNTO > ":" num = num() "," name = < NAME >
	  
	  {
	    if(ejecutar == true) {
	      if(listaVariables.contains(name.image)) {
	      mapaVariables.put(name.image, num);
	    } else {
	      throw new Error("La variable '"+name.image+"' debe ser declarada antes de usarse.");
	    }
	    
	    }
	    
	   }
	   
	 //---------------------goTo--------------------------
	| < GOTO > ":" (xInt = num()| xVar = < NAME >) "," (yInt = num()| yVar = < NAME >)
	
	{
	  if(ejecutar == true) {
	    if(xVar.image != null && mapaVariables.containsKey(xVar.image)) {
		  xInt = mapaVariables.get(xVar.image);
		} else if (xVar.image != null && !mapaVariables.containsKey(xVar.image)) {
		  throw new Error("La variable "+xVar+" debe ser declarada antes de usarse.");
		}

		if(yVar.image != null && mapaVariables.containsKey(yVar.image)) {
		  yInt = mapaVariables.get(yVar.image);
		} else if (yVar.image != null && !mapaVariables.containsKey(yVar.image)) {
		  throw new Error("La variable "+yVar.image+" debe ser declarada antes de usarse.");
		}
		
		try {
			world.setPostion(xInt,yInt);
		} catch(Exception e) {
		  System.out.println(e);
		}
	  }
		
		
	}

	//---------------------Move----------------------------
	| < MOVE > ":" (num = num()| name = < NAME >)
	{
	  if (ejecutar == true) {
	    if(name.image != null && mapaVariables.containsKey(name.image)) {
		  num = mapaVariables.get(name.image);
		} else if (name.image != null && !mapaVariables.containsKey(name.image)) {
		  throw new Error("La variable "+name.image+" debe ser declarada antes de usarse.");
		}

		world.moveForward(num, false);
		
	    }
	  
	}

	//--------------------------TURN--------------------------------
	| turn()  //< TURN > ":" (name = < LEFT >| name = < RIGHT >| name = < AROUND >)

	// Falta saber que hace Around

	
	//---------------------------FACE---------------------------------
	| < FACE > ":" ( name = < NORTH >| name = < SOUTH >| name = < EAST >| name = < WEST >)


	

	| < PUT > ":" (num = num()|name = < NAME >) "," (< BALLOONS >|< CHIPS >)

	| < PICK > ":" (num = num()|name = < NAME >) "," (< BALLOONS >|< CHIPS >)

	| < MOVETOTHE > ":" (num = num()|name = < NAME >) "," (< FRONT >|< RIGHT >|< LEFT >|< BACK >)

	| < MOVEINDIR > ":" (num = num()|name = < NAME >) "," (< NORTH >|< SOUTH >|< EAST >|< WEST >)

	| < JUMPTOTHE > ":" (num = num()|name = < NAME >) "," (< FRONT >|< RIGHT >|< LEFT >|< BACK >)

	| < JUMPINDIR > ":" (num = num()|name = < NAME >) "," (< NORTH >|< SOUTH >|< EAST >|< WEST >)

	| < NOP > ":"
	}

	void conditions():
	{}
	{
	  < FACING > ":" < NORTH >|< SOUTH >|< EAST >|< WEST >
	| < CANPUT > ":" num() "," (< BALLOONS >|< CHIPS >)
	| < CANPICK > ":" num() "," (< BALLOONS >|< CHIPS >)
	| < CANMOVEINDIR > ":" num() "," (< NORTH >|< SOUTH >|< EAST >|< WEST >)
	| < CANJUMPINDIR > ":" num() "," (< NORTH >|< SOUTH >|< EAST >|< WEST >)
	| < CANMOVETOTHE > ":" num() "," (< FRONT >|< RIGHT >|< LEFT >|< BACK >)
	| < CANJUMPTOTHE > ":" num() "," (< FRONT >|< RIGHT >|< LEFT >|< BACK >)
//	| < NOT > ":" (conditions()) Se debe corregir... no se puede llamar la funcion conditions dentro de si misma
	}


	void put() :
	{
		int f=1;	
	}
	{
		( <CHIPS>    "," f=num() {world.putChips(f); salida = "Command:  Put Chips"; })
		|  	  ( <BALLOONS>   "," f=num() {world.putBalloons(f); salida = "Command:  Put Balloons";})	 

	}

	void get() :
	{
		int f=1;	
	}
	{
		( <CHIPS>   "," f=num() {world.pickChips(f);salida = "Command:  Pick chips";})
		|  	  ( <BALLOONS>   "," f=num() {world.grabBalloons(f);salida="Command:  Pick balloons";})	 
	}
	

	void turn():
	{
	  Token name = new Token();
	}
	{
	  < TURN > ":" (name = < LEFT >| name = < RIGHT >| name = < AROUND >)

	// Falta saber que hace Around

	  /*	public static final int NORTH = 0;
	public static final int SOUTH = 1;
	public static final int EAST = 2;
	public static final int WEST = 3; */

	{
		if(ejecutar == true) {

		  int facing = world.getFacing();


		  if((name.image).toUpperCase().equals("LEFT")) {
		    if(facing == 0) {
		      world.turnRight();
		      world.turnRight();
		      world.turnRight();
		    } else if(facing == 1) {
		      world.turnRight();
		    } else if(facing == 2) {
		      world.turnRight();
		    }

		  } else if((name.image).toUpperCase().equals("RIGHT")) {
		    if(facing == 0) {
		      world.turnRight();
		    } else if(facing == 1) {
		      world.turnRight();
		      world.turnRight();
		      world.turnRight();
		    } else if(facing == 3) {
		      world.turnRight();
		      world.turnRight();
		    }
		  
		} /*else if((name.image).toUpperCase().equals("AROUND")) {
		  Falta saber que es around
		}*/
	}

	}

	
	  
	}



// Producciones

	int one_line() :
	{}
	{
  	(robot())
  	{
    	return (int) Math.pow(2,3);
  	}
	}

	

	void robot() :	
	{}
	{
 	< ROBOT_R >  (vars())  procedures() inst() 
	}


	
	void vars() :	
	{
	Token var = new Token();
	}
	  
	{
 	< VARS >  ((var = < NAME >) (",")? { listaVariables.add(var.image);} )* ";" 	
 	}
	
	
	void listofnames() :	
	{}
	{
 	((< NAME >) (",")?)*
	}

	void procedures() :	
	{
	ejecutar = false;
	  }
	{
 	(< PROCS >) (procdef())*
	}

	void procdef() :	
	{}
	{
 	(< NAME >) "[" parameters() (instructions()) "]"
	}
	
	void parameters() :	
	{}
	{
 	"|" (listofnames()) "|"
	}

	void instructions() :	
	{
	
	}
	
	{
 	(("[")(instruction())+ ("]")) | (instruction())+

	}

	

	void instruction() :	
	{}
	{
 	(command2()
	| (< IF > ":" conditions() < THEN > ":" instructions()  < ELSE > ":" instructions()) | (< WHILE > ":" conditions() < DO > ":" instructions()) | (< REPEAT > ":" < NUM > instructions())) (";")?
	}
	
	void inst():
	{if(ejecutar == false) {
	  ejecutar = true;} }
	{
	"[" ((instruction()| < NAME > ":" ((num()|< NAME >) (",")?)* ) (";")?)* "]"
	}


	
	/**
	 * Unsigned decimal number
	 * @return the corresponding value of the string
	 * @error  corresponding value is too large
	 */


	int num() throws Error:
	{	
		int total=1;
	}
	{
		<NUM>
		{
			try 
			{
				total = Integer.parseInt(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Numero fuera de rango: "+token.image+" !!");
			}
			return total;
		}
	}

	